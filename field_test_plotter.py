#!/usr/bin/env python

import argparse
import logging
from colorlog import ColoredFormatter
import time
import os
import csv
import geo
import datetime
import pytz
import dateutil.parser
import numpy as np
import matplotlib.pyplot as plt

def extract_from_df_results(directory):
    """ Directory is the location of a results.txt file
    Offset is how much the DF is artificially rotated. This will be subtracted from real results
    Return a hash mapping t -> aoa from a results file as generated by the DF
    Test for either 2 columns or N columns.
    """
    results = {}
    with open("{d}/results.txt".format(d = directory)) as f:
        for row in csv.reader(f):
            if len(row) == 3:
                # t, f , aoa (rads)
                dt = datetime.datetime.fromtimestamp(float(row[0]))
                freq = round(float(row[1]) / 1e6, 3)
                aoa = float(row[2])
            if len(row) == 2:
                # t, aoa (rads)
                dt = datetime.datetime.fromtimestamp(float(row[0]))
                freq = 'impulse'
                aoa = float(row[1])
            dt = dt.replace(tzinfo = pytz.timezone('Etc/GMT-2'))
            aoa = np.arctan2(np.sin(aoa), np.cos(aoa))  # wrap to -pi/pi
            if freq not in results:
                results[freq] = {}
            results[freq][dt] = aoa
    return results

def extract_from_gps_logs(directory, rx_pos, offset):
    """ midpoint is a geo.xyz
    Returns a hash mapping t -> aoa 
    for a GPS log file generated from the phone
    """
    gps = {}
    with open("{d}/gps.txt".format(d = directory)) as f:
        reader = csv.reader(f)
        for row in reader:
            # time,lat,lon,elevation,accuracy,bearing,speed
            if len(row) == 7:
                dt = dateutil.parser.parse(row[0])
                tx_pos = geo.xyz(float(row[1]), float(row[2]))
                bearing = geo.great_circle_angle(tx_pos, rx_pos, geo.geographic_northpole)
                bearing = np.radians(bearing)
                bearing = -bearing + offset
                bearing = np.arctan2(np.sin(bearing), np.cos(bearing))  # wrap to -pi/pi
                gps[dt] = bearing
    return gps

if __name__ == '__main__':
    # setup root logger. Shouldn't be used much but will catch unexpected messages
    colored_formatter = ColoredFormatter("%(log_color)s%(asctime)s:%(levelname)s:%(name)s:%(message)s")
    handler = logging.StreamHandler()
    handler.setFormatter(colored_formatter)
    handler.setLevel(logging.DEBUG)

    root = logging.getLogger()
    root.addHandler(handler)
    root.setLevel(logging.INFO)

    logger = logging.getLogger('main')
    logger.propagate = False
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)

    parser = argparse.ArgumentParser(description = "Run RMS error simulations")
    parser.add_argument('--t_start', default=1452841400, type=float)
    parser.add_argument('--t_stop',  default=1452848400, type=float)
    parser.add_argument('--t_offset', default=None, type=float)
    parser.add_argument('--aoa_offset', default=136.5, type=float)
    parser.add_argument('--d', type=str)
    args = parser.parse_args()

    rx_pos = geo.xyz(-33.956093444444, 18.467267555556)

    t_start = datetime.datetime.fromtimestamp(float(args.t_start))
    t_start = t_start.replace(tzinfo = pytz.timezone('Etc/GMT-2'))
    t_stop  = datetime.datetime.fromtimestamp(float(args.t_stop))
    t_stop  = t_stop.replace(tzinfo = pytz.timezone('Etc/GMT-2'))

    results = extract_from_df_results(args.d)
    results_freqs = results.keys()
    results_freqs = sorted(results_freqs, key=lambda freq: len(results[freq]), reverse=True)
    for freq in results_freqs:
        results_keys = results[freq].keys()
        results_keys = [k for k in results_keys if k >= t_start]
        results_keys = [k for k in results_keys if k <= t_stop]
        results_keys.sort()
        results_vals = [results[freq][x] for x in results_keys]
        #results_vals = np.unwrap(results_vals[::-1])[::-1]
        delta_t = [(t - t_start).total_seconds() for t in results_keys]
        if len(results_vals) > 0:
            plt.plot(delta_t, results_vals, linestyle='', marker='o', label=freq)
    plt.legend(title = 'Frequency (MHz):')

    # remove time offset by converting to t - t_start (seconds)

    gps = extract_from_gps_logs(args.d, rx_pos, np.radians(args.aoa_offset))
    gps_keys = gps.keys()
    gps_keys = [k for k in gps_keys if k >= t_start]
    gps_keys = [k for k in gps_keys if k <= t_stop]
    gps_keys.sort()
    gps_vals = [gps[x] for x in gps_keys]
    #gps_vals = np.unwrap(gps_vals[::-1])[::-1]
    delta_t = [(t - t_start).total_seconds() for t in gps_keys]
    plt.plot(delta_t, gps_vals, color='red', linewidth=2)
    plt.title("GPS track vs DF system output for DEVICE (f MHz - f MHz)")
    plt.xlabel("Time (s)")
    plt.ylabel("Angle (rads)")
    plt.show()
